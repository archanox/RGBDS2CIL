<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\pierc\source\repos\RGBDS2CIL\RGBDS2CIL\Parser.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;

namespace RGBDS2CIL
{
	public static class Parser
	{
		private static readonly Regex CommentRegex = new Regex(@&quot;(;.*?(\r?\n|$))|(&quot;&quot;(?:\\[^\n]|[^&quot;&quot;\n])*&quot;&quot;)|(@(?:&quot;&quot;[^&quot;&quot;]*&quot;&quot;)+)&quot;, RegexOptions.Compiled);

		private static readonly Regex GetStringsRegex = new(&quot;((?&lt;![\\\\])[&#39;\&quot;])((?:.(?!(?&lt;![\\\\])\\1))*.?)\\1&quot;,
			RegexOptions.Compiled | RegexOptions.IgnoreCase);

		internal static string RootFolder { get; set; }
		private static List&lt;LabelLine&gt; Labels { get; } = new();
		private static List&lt;ConstantLine&gt; Constants { get; } = new();

		internal static void ExportJson(string fileName, List&lt;IAsmLine&gt; parsedLines)
		{
			var settings = new JsonSerializerSettings
			{
				TypeNameHandling = TypeNameHandling.Auto,
				Formatting = Formatting.Indented
			};
			var serialized = JsonConvert.SerializeObject(parsedLines, settings);
			File.WriteAllText(fileName + &quot;.json&quot;, serialized);
		}

		internal static string[] FlattenMultiLine(IList&lt;string&gt; fileLines)
		{
			for (var i = 0; i &lt; fileLines.Count; i++)
			{
				if (string.IsNullOrWhiteSpace(fileLines[i])) continue;

				//var comment = GetComment(fileLines[i]);
				var code = RemoveCommentFromCode(fileLines[i]);

				if (code?.EndsWith(&#39;\\&#39;) != true) continue;
				var rowSkip = i + 1;
				var hasMore = true;

				while (hasMore)
				{
					var comment = GetComment(fileLines[i]);
					code = RemoveCommentFromCode(fileLines[i]);

					var fileLine2 = fileLines[rowSkip];
					var comment2 = GetComment(fileLine2);
					var code2 = RemoveCommentFromCode(fileLine2);
					hasMore = code2.EndsWith(&#39;\\&#39;);

					fileLines[i] =
						$&quot;{code.TrimEnd(&#39;\\&#39;)} {code2} {((!string.IsNullOrWhiteSpace(comment) || !string.IsNullOrWhiteSpace(comment2)) ? &quot;; &quot; : &quot; &quot;)}{(comment + &quot; &quot; + comment2).Trim()}&quot;
							.Trim();

					fileLines[rowSkip] = null;

					rowSkip++;
				}
			}

			return fileLines.Where(x =&gt; x is not null).ToArray();
		}

		public static List&lt;IAsmLine&gt; GetLines(IEnumerable&lt;string&gt; fileLines, string fileName) =&gt; fileLines
			//.AsParallel().AsOrdered()
			.SelectMany&lt;string, IAsmLine&gt;((x, y) =&gt; ParseLine(x, fileName, y)).ToList();

		internal static IEnumerable&lt;IAsmLine&gt; ParseLine(string fileLine, string fileName, int line)
		{
			var parsedLines = new List&lt;IAsmLine&gt;();

			var comment = GetComment(fileLine);

			var code = RemoveCommentFromCode(fileLine);

			if (code == null)
			{
				parsedLines.Add(new CommentLine(fileLine, comment, fileName, line));
			}
			else
			{
				var codeLine = new CodeLine(code, fileLine, comment, fileName, line, GetStrings(code));

				if (MyExtensions.CommandName(code, &quot;INCLUDE&quot;))
				{
					var includeFile = new IncludeLine(codeLine, false);
					var path = Path.Combine(RootFolder, includeFile.IncludeFile);
					if (File.Exists(path))
						includeFile.Lines.AddRange(GetLines(FlattenMultiLine(File.ReadAllLines(path)), includeFile.IncludeFile));
					//else
					//	throw new FileNotFoundException(&quot;Could not include file&quot;, includeFile.IncludeFile);
					parsedLines.Add(includeFile);
				}
				else if (MyExtensions.CommandName(code, &quot;INCBIN&quot;))
				{
					var binary = new IncludeLine(codeLine, true);
					var path = Path.Combine(RootFolder, binary.IncludeFile);
					if (File.Exists(path))
						binary.Binary = File.ReadAllBytes(path);
					//else
					//	throw new FileNotFoundException(&quot;Could not include binary&quot;, binary.IncludeFile);
					parsedLines.Add(binary);
				}
				else if (MyExtensions.CommandName(code, &quot;SECTION&quot;))
					parsedLines.Add(new SectionLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;JP&quot;))
					parsedLines.Add(new JumpLine(codeLine));




				else if (code.StartsWith(&#39;.&#39;) || code.EndsWith(&#39;:&#39;) || code.Split()[0].EndsWith(&quot;::&quot;) ||
						 code.Split()[0].EndsWith(&quot;:&quot;))
				{
					var split = code.Split();

					if (string.Equals(split.Last(), &quot;MACRO&quot;, StringComparison.OrdinalIgnoreCase))
					{
						parsedLines.Add(new MacroLine(codeLine, split[0]));
					}
					else
					{

						codeLine.Code = split[0];
						var label = new LabelLine(codeLine);
						Labels.Add(label);

						parsedLines.Add(label);
						if (split.Length &gt; 1)
						{
							//Console.Error.WriteLine(code[codeLine.Code.Length..].Trim() + &quot; [&quot; + code + &quot;]&quot;);
							//parsedLines.AddRange(ParseLine(code[codeLine.Code.Length..], fileName, line));
						}
					}
				}
				else if (MyExtensions.CommandName(code, &quot;ENDM&quot;))
					parsedLines.Add(new EndMacroLine(codeLine));

				else if (Enumerable.Contains(code.Trim().ToUpper().Split(), &quot;EQU&quot;))
				{
					var constant = new ConstantLine(codeLine, &quot;EQU&quot;);
					Constants.Add(constant);
					parsedLines.Add(constant);
				}
				else if (Enumerable.Contains(code.Trim().ToUpper().Split(), &quot;EQUS&quot;))
				{
					var constant = new ConstantLine(codeLine, &quot;EQUS&quot;);
					Constants.Add(constant);
					parsedLines.Add(constant);
				}
				else if (code.Trim().Split().Length &gt; 1 &amp;&amp; Enumerable.Skip&lt;string&gt;(code.Trim().Split(), 1).First() == &quot;=&quot;)
				{
					var constant = new ConstantLine(codeLine, &quot;=&quot;);
					Constants.Add(constant);
					parsedLines.Add(constant);
				}
				else if (Enumerable.Contains(code.Trim().ToUpper().Split(), &quot;SET&quot;))
					parsedLines.Add(new VariableLine(codeLine));
				else if (code.ToUpper().Trim() == &quot;NOP&quot;)
					parsedLines.Add(new NopLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;LD&quot;))
					parsedLines.Add(new LoadLine(codeLine, &quot;LD&quot;));
				else if (MyExtensions.CommandName(code, &quot;LDI&quot;))
					parsedLines.Add(new LoadLine(codeLine, &quot;LDI&quot;));
				else if (MyExtensions.CommandName(code, &quot;LDD&quot;))
					parsedLines.Add(new LoadLine(codeLine, &quot;LDD&quot;));
				else if (MyExtensions.CommandName(code, &quot;CALL&quot;))
					parsedLines.Add(new CallLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;RST&quot;))
					parsedLines.Add(new RestartLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;CP&quot;))
					parsedLines.Add(new SubtractCompareLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;PUSHO&quot;))
					parsedLines.Add(new PushOptionLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;POPO&quot;))
					parsedLines.Add(new PopOptionLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;DI&quot;))
					parsedLines.Add(new DisableInterruptsLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;HALT&quot;))
					parsedLines.Add(new HaltLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;JR&quot;))
					parsedLines.Add(new RelativeJumpLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;XOR&quot;))
					parsedLines.Add(new ExclusiveOrLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;ADD&quot;))
					parsedLines.Add(new AddLine(codeLine, false));
				else if (MyExtensions.CommandName(code, &quot;ADC&quot;))
					parsedLines.Add(new AddLine(codeLine, true));
				else if (MyExtensions.CommandName(code, &quot;INC&quot;))
					parsedLines.Add(new IncrementLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;DEC&quot;))
					parsedLines.Add(new DecrementLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;SUB&quot;))
					parsedLines.Add(new SubtractLine(codeLine, false));
				else if (MyExtensions.CommandName(code, &quot;SBC&quot;))
					parsedLines.Add(new SubtractLine(codeLine, true));
				else if (MyExtensions.CommandName(code, &quot;DB&quot;)) //byte 8bit
					parsedLines.Add(new DefineLine(codeLine, typeof(byte)));
				else if (MyExtensions.CommandName(code, &quot;DW&quot;)) //word 16bit (short)
					parsedLines.Add(new DefineLine(codeLine, typeof(short)));
				else if (MyExtensions.CommandName(code, &quot;DL&quot;)) //double-word/long 32bit (int)
					parsedLines.Add(new DefineLine(codeLine, typeof(int)));
				else if (MyExtensions.CommandName(code, &quot;ENDR&quot;))
					parsedLines.Add(new EndRepeatLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;ENDC&quot;))
					parsedLines.Add(new EndConditionLine(codeLine));

				else if (MyExtensions.CommandName(code, &quot;WARN&quot;))
					parsedLines.Add(new WarnLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;FAIL&quot;))
					parsedLines.Add(new FailLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;CHARMAP&quot;))
					parsedLines.Add(new CharMapLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;IF&quot;))
					parsedLines.Add(new IfLine(codeLine, false));
				else if (MyExtensions.CommandName(code, &quot;ELIF&quot;))
					parsedLines.Add(new IfLine(codeLine, true));
				else if (MyExtensions.CommandName(code, &quot;ELSE&quot;))
					parsedLines.Add(new ElseLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;RET&quot;))
					parsedLines.Add(new ReturnLine(codeLine, false));
				else if (MyExtensions.CommandName(code, &quot;RETI&quot;))
					parsedLines.Add(new ReturnLine(codeLine, true));
				else if (string.Equals(code, &quot;EI&quot;, StringComparison.OrdinalIgnoreCase))
					parsedLines.Add(new EnableInterruptsLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;PURGE&quot;))
					parsedLines.Add(new PurgeLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;REPT&quot;))
					parsedLines.Add(new RepeatLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;SHIFT&quot;))
					parsedLines.Add(new ShiftLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;POP&quot;))
					parsedLines.Add(new PopLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;PUSH&quot;))
					parsedLines.Add(new PushLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;RL&quot;))
					parsedLines.Add(new RotateLeftLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;RLA&quot;))
					parsedLines.Add(new RotateALeftLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;BIT&quot;))
					parsedLines.Add(new BitLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;LDH&quot;))
					parsedLines.Add(new LoadHighLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;AND&quot;))
					parsedLines.Add(new AndLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;CPL&quot;))
					parsedLines.Add(new ComplementLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;RRCA&quot;))
					parsedLines.Add(new RotateRegisterARightLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;RLCA&quot;))
					parsedLines.Add(new RotateRegisterALeftLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;RES&quot;))
					parsedLines.Add(new ResetByteLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;SCF&quot;))
					parsedLines.Add(new SetCarryFlagLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;CCF&quot;))
					parsedLines.Add(new ComplementCarryFlagLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;OPT&quot;))
					parsedLines.Add(new OptionLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;OR&quot;))
					parsedLines.Add(new OrLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;DS&quot;))
					parsedLines.Add(new DeclareSpaceLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;SWAP&quot;))
					parsedLines.Add(new SwapLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;RR&quot;))
					parsedLines.Add(new RotateRegisterRightLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;SRL&quot;))
					parsedLines.Add(new ShiftRightLogicLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;SLA&quot;))
					parsedLines.Add(new ShiftLeftArithmeticLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;DAA&quot;))
					parsedLines.Add(new DecimalAdjustAccumulatorLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;RRA&quot;))
					parsedLines.Add(new RotateRegisterRightLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;STOP&quot;)) //do &lt;--
					parsedLines.Add(new StopLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;ASSERT&quot;))
					parsedLines.Add(new AssertLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;RRC&quot;)) //do &lt;--
					parsedLines.Add(new RotateRegisterRightLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;RLC&quot;)) //do &lt;--
					parsedLines.Add(new RotateRegisterLeftLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;SRA&quot;)) //do &lt;--
					parsedLines.Add(new ShiftRightArithmeticLine(codeLine));
				else if (MyExtensions.CommandName(code, &quot;LOAD&quot;)) //do &lt;--
					parsedLines.Add(new Load2Line(codeLine));
				else if (MyExtensions.CommandName(code, &quot;ENDL&quot;)) //do &lt;--
					parsedLines.Add(new EndLoadLine(codeLine));

				//else if (code.CommandName(&quot;LB&quot;)) //do
				//else if (code.CommandName(&quot;LDI&quot;)) //do &lt;--
				//else if (code.CommandName(&quot;LDD&quot;)) //do &lt;--
				//else if (code.CommandName(&quot;DN&quot;)) //do &lt;--

				//else if (code.CommandName(&quot;UNION&quot;))
				//	parsedLines.Add(new UnionLine(codeLine));
				//else if (code.CommandName(&quot;NEXTU&quot;))
				//	parsedLines.Add(new NextUnionLine(codeLine));
				//else if (code.CommandName(&quot;ENDU&quot;))
				//	parsedLines.Add(new EndUnionLine(codeLine));

				//https://rgbds.gbdev.io/docs/master/rgblink.5#ORG
				//note: moves out the address
				//else if (code.CommandName(&quot;ORG&quot;))
				//	parsedLines.Add(new OrgLine(codeLine));

				//ifdef
				// c# = &quot;#if (DEBUG)&quot;
				//endif
				// c# = &quot;#endif&quot;

				else if (code.StartsWith(&#39;\\&#39;) &amp;&amp; char.IsDigit(code.ToUpper()[1]))
					parsedLines.Add(new MacroArgumentLine(codeLine));
				else if (Labels.Select(x =&gt; x.LabelName.ToUpper()).Contains(codeLine.Code.Split()[0].ToUpper()))
				{
					var labelName = codeLine.Code.Split()[0].ToUpper();
					var labels = Labels
						.Where(x =&gt; string.Equals(x.LabelName, labelName, StringComparison.OrdinalIgnoreCase))
						.ToImmutableArray();
					if (labels.Length &gt; 1)
					{
						//TODO: need to remove already declared shit, unless it&#39;s scoped differently?
						//Debugger.Break();
						//TODO: get proper name spaced label
						//codeLine.Dump();
						//labels.Dump();
					}

					var label = labels.FirstOrDefault();
					parsedLines.Add(new LabelCallLine(codeLine, label));
				}

				else if (Constants.Select(x =&gt; x.ConstantName.ToUpper())
					.Contains(codeLine.Code.Split()[0].Trim().ToUpper()))
				{
					var constantName = codeLine.Code.Split()[0].Trim().ToUpper();

					var constants = Constants
						.Where(x =&gt; string.Equals(x.ConstantName, constantName, StringComparison.OrdinalIgnoreCase))
						.ToImmutableArray();
					if (constants.Length &gt; 1)
					{
						//Debugger.Break();
						//codeLine.Dump();
						//constants.Dump();
					}

					var constant = constants.FirstOrDefault();
					parsedLines.Add(new ConstantAssignLine(codeLine, constant));
				}
				else
				{
					//Console.WriteLine(codeLine.Code.Trim().Split()[0]);
					//Console.WriteLine(codeLine.FileName);
					//Debugger.Break();
					//parsedLines.Add(codeLine);
					//throw new NotImplementedException($&quot;Instruction {codeLine.Code.Split()[0]} not implemented.&quot;);
				}
			}

			return parsedLines.ToArray();
		}

		public static string RemoveCommentFromCode(string fileLine)
		{
			var code = CommentRegex.Replace(fileLine, me =&gt; me.Value.StartsWith(&quot;;&quot;) ? me.Groups[2].Value : me.Value).Trim();

			if (string.IsNullOrWhiteSpace(code))
				code = null;
			return code?.Trim();
		}

		public static string GetComment(string fileLine)
		{
			if (fileLine == null)
				throw new ArgumentNullException(nameof(fileLine));
			var clean = CommentRegex.Replace(fileLine, me =&gt; me.Value.StartsWith(&quot;;&quot;) ? me.Groups[2].Value : me.Value).Trim();

			var comment = fileLine.Remove(fileLine.IndexOf(clean), clean.Length).Trim().TrimStart(&#39;;&#39;).Trim();

			if (string.IsNullOrWhiteSpace(comment))
				comment = null;
			return comment?.Trim();
		}

		public static List&lt;string&gt; GetStrings(string code)
		{
			if (string.IsNullOrWhiteSpace(code)) return new List&lt;string&gt;();

			var matches = GetStringsRegex.Matches(code);

			var returned = matches.Select(x =&gt; x.Value?.TrimStart(&#39;&quot;&#39;).TrimEnd(&#39;&quot;&#39;)).ToList();

			return returned.Count &gt; 0 ? returned : null;
		}

		public static List&lt;string&gt; GetParameters(string code)
		{
			if (string.IsNullOrWhiteSpace(code)) return new List&lt;string&gt;();

			var matches = new List&lt;string&gt;();

			while (code.Length &gt; 0)
			{
				var parameter = GetParameter(code);
				matches.Add(parameter);
				code = code[parameter.Length..].TrimStart(&#39;,&#39;).Trim();
			}

			return matches.Count &gt; 0 ? matches : null;
		}

		private static string GetParameter(string code)
		{
			var i = 0;
			var isString = code[0] == &#39;\&quot;&#39;;
			for (; i &lt; code.Length; i++)
			{
				if (!isString &amp;&amp; code[i] == &#39;,&#39;) break;
				if (!isString || i &lt;= 0 || code[i] != &#39;\&quot;&#39; || code[i - 1] == &#39;\\&#39;) continue;
				i++;
				break;
			}

			return code.Substring(0, i);
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[13,3,13,147,1],[15,3,16,53,1],[18,39,18,43,1],[18,44,18,48,1],[19,43,19,47,1],[19,52,19,57,1],[20,49,20,53,1],[20,58,20,63,1],[23,3,23,4,1],[24,4,28,6,1],[29,4,29,72,1],[30,4,30,54,1],[31,3,31,4,1],[34,3,34,4,1],[35,9,35,18,1],[35,20,35,39,1],[35,41,35,44,1],[36,4,36,5,1],[37,5,37,49,1],[37,50,37,59,1],[40,5,40,52,1],[42,5,42,38,1],[42,39,42,48,1],[43,5,43,25,0],[44,5,44,24,0],[46,5,46,20,0],[47,5,47,6,0],[48,6,48,45,0],[49,6,49,49,0],[51,6,51,41,0],[52,6,52,43,0],[53,6,53,51,0],[54,6,54,37,0],[56,6,58,16,0],[60,6,60,32,0],[62,6,62,16,0],[63,5,63,6,0],[64,4,64,5,0],[66,4,66,32,1],[66,32,66,45,1],[66,45,66,57,1],[66,4,66,57,1],[67,3,67,4,1],[69,92,71,44,1],[71,44,71,69,1],[71,69,71,79,1],[69,92,71,79,1],[74,3,74,4,1],[75,4,75,43,1],[77,4,77,39,1],[79,4,79,47,1],[81,4,81,21,1],[82,4,82,5,1],[83,5,83,73,1],[84,4,84,5,1],[86,4,86,5,1],[87,5,87,92,1],[89,5,89,51,1],[90,5,90,6,1],[91,6,91,57,1],[92,6,92,67,1],[93,6,93,28,1],[94,7,94,112,1],[97,6,97,35,1],[98,5,98,6,1],[99,10,99,55,1],[100,5,100,6,1],[101,6,101,51,1],[102,6,102,62,1],[103,6,103,28,1],[104,7,104,47,1],[107,6,107,30,1],[108,5,108,6,1],[109,10,109,56,1],[110,6,110,49,1],[111,10,111,51,1],[112,6,112,46,1],[117,10,118,38,1],[119,5,119,6,1],[120,6,120,31,1],[122,6,122,83,1],[123,6,123,7,1],[124,7,124,58,1],[125,6,125,7,1],[127,6,127,7,1],[129,7,129,32,1],[130,7,130,43,1],[131,7,131,25,1],[133,7,133,30,1],[134,7,134,28,1],[135,7,135,8,1],[138,7,138,8,1],[139,6,139,7,1],[140,5,140,6,1],[141,10,141,53,1],[142,6,142,50,1],[144,10,144,72,1],[145,5,145,6,1],[146,6,146,55,1],[147,6,147,30,1],[148,6,148,32,1],[149,5,149,6,1],[150,10,150,73,1],[151,5,151,6,0],[152,6,152,56,0],[153,6,153,30,0],[154,6,154,32,0],[155,5,155,6,0],[156,10,156,111,1],[157,5,157,6,0],[158,6,158,53,0],[159,6,159,30,0],[160,6,160,32,0],[161,5,161,6,0],[162,10,162,72,1],[163,6,163,50,1],[164,10,164,45,1],[165,6,165,45,1],[166,10,166,51,1],[167,6,167,52,1],[168,10,168,52,1],[169,6,169,53,1],[170,10,170,52,1],[171,6,171,53,1],[172,10,172,53,1],[173,6,173,46,1],[174,10,174,52,1],[175,6,175,49,1],[176,10,176,51,1],[177,6,177,57,1],[178,10,178,54,1],[179,6,179,52,1],[180,10,180,53,1],[181,6,181,51,1],[182,10,182,51,1],[183,6,183,59,1],[184,10,184,53,1],[185,6,185,46,1],[186,10,186,51,1],[187,6,187,54,1],[188,10,188,52,1],[189,6,189,53,1],[190,10,190,52,1],[191,6,191,52,1],[192,10,192,52,1],[193,6,193,51,1],[194,10,194,52,1],[195,6,195,51,1],[196,10,196,52,1],[197,6,197,51,1],[198,10,198,52,1],[199,6,199,57,1],[200,10,200,52,1],[201,6,201,56,1],[202,10,202,51,1],[203,6,203,62,1],[204,10,204,51,1],[205,6,205,63,1],[206,10,206,51,1],[207,6,207,61,0],[208,10,208,53,1],[209,6,209,51,0],[210,10,210,53,1],[211,6,211,54,1],[213,10,213,53,1],[214,6,214,46,1],[215,10,215,53,1],[216,6,216,46,1],[217,10,217,56,1],[218,6,218,49,0],[219,10,219,51,1],[220,6,220,51,1],[221,10,221,53,1],[222,6,222,50,0],[223,10,223,53,1],[224,6,224,46,0],[225,10,225,52,1],[226,6,226,55,1],[227,10,227,53,1],[228,6,228,54,1],[229,10,229,76,1],[230,6,230,58,1],[231,10,231,54,1],[232,6,232,47,0],[233,10,233,53,1],[234,6,234,48,0],[235,10,235,54,1],[236,6,236,47,0],[237,10,237,52,1],[238,6,238,45,1],[239,10,239,53,1],[240,6,240,46,1],[241,10,241,51,1],[242,6,242,52,0],[243,10,243,52,1],[244,6,244,53,1],[245,10,245,52,1],[246,6,246,45,1],[247,10,247,52,1],[248,6,248,50,1],[249,10,249,52,1],[250,6,250,45,1],[251,10,251,52,1],[252,6,252,52,1],[253,10,253,53,1],[254,6,254,62,1],[255,10,255,53,1],[256,6,256,61,1],[257,10,257,52,1],[258,6,258,51,1],[259,10,259,52,1],[260,6,260,54,0],[261,10,261,52,1],[262,6,262,61,0],[263,10,263,52,1],[264,6,264,48,1],[265,10,265,51,1],[266,6,266,44,1],[267,10,267,51,1],[268,6,268,54,0],[269,10,269,53,1],[270,6,270,46,1],[271,10,271,51,1],[272,6,272,61,1],[273,10,273,52,1],[274,6,274,57,1],[275,10,275,52,1],[276,6,276,61,1],[277,10,277,52,1],[278,6,278,66,1],[279,10,279,52,1],[280,6,280,61,1],[281,10,281,53,1],[282,6,282,46,0],[283,10,283,55,1],[284,6,284,48,0],[285,10,285,52,1],[286,6,286,61,0],[287,10,287,52,1],[288,6,288,60,0],[289,10,289,52,1],[290,6,290,62,0],[291,10,291,53,1],[292,6,292,47,0],[293,10,293,53,1],[294,6,294,49,0],[318,10,318,71,1],[319,6,319,55,0],[320,10,320,33,1],[320,33,320,54,1],[320,54,320,101,1],[320,10,320,101,1],[321,5,321,6,1],[322,6,322,57,1],[323,6,324,19,1],[324,19,324,92,1],[324,92,325,27,1],[323,6,325,27,1],[326,6,326,28,1],[327,6,327,7,1],[333,6,333,7,1],[335,6,335,42,1],[336,6,336,58,1],[337,5,337,6,1],[339,10,339,36,1],[339,36,339,60,1],[339,60,340,59,1],[339,10,340,59,1],[341,5,341,6,0],[342,6,342,67,0],[344,6,345,19,0],[345,19,345,98,0],[345,98,346,27,0],[344,6,346,27,0],[347,6,347,31,0],[348,6,348,7,0],[352,6,352,7,0],[354,6,354,48,0],[355,6,355,66,0],[356,5,356,6,0],[358,5,358,6,1],[364,5,364,6,1],[365,4,365,5,1],[367,4,367,33,1],[368,3,368,4,1],[371,3,371,4,1],[372,4,372,52,1],[372,52,372,108,1],[372,108,372,117,1],[372,4,372,117,1],[374,4,374,40,1],[375,5,375,17,1],[376,4,376,24,1],[377,3,377,4,1],[380,3,380,4,1],[381,4,381,25,1],[382,5,382,55,0],[383,4,383,53,1],[383,53,383,109,1],[383,109,383,118,1],[383,4,383,118,1],[385,4,385,102,1],[387,4,387,43,1],[388,5,388,20,1],[389,4,389,27,1],[390,3,390,4,1],[393,3,393,4,1],[394,4,394,40,1],[394,41,394,67,0],[396,4,396,48,1],[398,4,398,39,1],[398,39,398,75,1],[398,75,398,86,1],[398,4,398,86,1],[400,4,400,48,1],[401,3,401,4,1],[404,3,404,4,1],[405,4,405,40,1],[405,41,405,67,0],[407,4,407,37,1],[409,4,409,27,1],[410,4,410,5,1],[411,5,411,40,1],[412,5,412,28,1],[413,5,413,59,1],[414,4,414,5,1],[416,4,416,46,1],[417,3,417,4,1],[420,3,420,4,1],[421,4,421,14,1],[422,4,422,35,1],[423,11,423,26,1],[423,28,423,31,1],[424,4,424,5,1],[425,5,425,37,1],[425,38,425,44,1],[426,5,426,71,1],[426,72,426,81,1],[427,5,427,9,1],[428,5,428,11,1],[431,4,431,32,1],[432,3,432,4,1]]);
    </script>
  </body>
</html>