<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\pierc\source\repos\RGBDS2CIL\RGBDS2CIL\CIL.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;

namespace RGBDS2CIL
{
	static class Cil
	{
		//use this instead
		//https://github.com/ltrzesniewski/InlineIL.Fody


		public static void GenerateCil()
		{
			var aName = new AssemblyName(&quot;DynamicAssemblyExample&quot;);
			var ab =
				AssemblyBuilder.DefineDynamicAssembly(
					aName,
					AssemblyBuilderAccess.RunAndCollect);

			// For a single-module assembly, the module name is usually
			// the assembly name plus an extension.
			var mb =
				ab.DefineDynamicModule(aName.Name);

			var tb = mb.DefineType(
				&quot;MyDynamicType&quot;,
				TypeAttributes.Public);

			// Add a private field of type int (Int32).
			var fbNumber = tb.DefineField(
				&quot;m_number&quot;,
				typeof(int),
				FieldAttributes.Private);

			// Define a constructor that takes an integer argument and
			// stores it in the private field.
			Type[] parameterTypes = { typeof(int) };
			var ctor1 = tb.DefineConstructor(
				MethodAttributes.Public,
				CallingConventions.Standard,
				parameterTypes);

			var ctor1IL = ctor1.GetILGenerator();
			// For a constructor, argument zero is a reference to the new
			// instance. Push it on the stack before calling the base
			// class constructor. Specify the default constructor of the
			// base class (System.Object) by passing an empty array of
			// types (Type.EmptyTypes) to GetConstructor.
			ctor1IL.Emit(OpCodes.Ldarg_0);
			ctor1IL.Emit(OpCodes.Call, typeof(object).GetConstructor(Type.EmptyTypes));
			// Push the instance on the stack before pushing the argument
			// that is to be assigned to the private field m_number.
			ctor1IL.Emit(OpCodes.Ldarg_0);
			ctor1IL.Emit(OpCodes.Ldarg_1);
			ctor1IL.Emit(OpCodes.Stfld, fbNumber);
			ctor1IL.Emit(OpCodes.Ret);


			// Define a default constructor that supplies a default value
			// for the private field. For parameter types, pass the empty
			// array of types or pass null.
			var ctor0 = tb.DefineConstructor(
				MethodAttributes.Public,
				CallingConventions.Standard,
				Type.EmptyTypes);

			var ctor0IL = ctor0.GetILGenerator();
			// For a constructor, argument zero is a reference to the new
			// instance. Push it on the stack before pushing the default
			// value on the stack, then call constructor ctor1.
			ctor0IL.Emit(OpCodes.Ldarg_0);
			ctor0IL.Emit(OpCodes.Ldc_I4_S, 42);
			ctor0IL.Emit(OpCodes.Call, ctor1);
			ctor0IL.Emit(OpCodes.Ret);

			// Define a property named Number that gets and sets the private
			// field.
			//
			// The last argument of DefineProperty is null, because the
			// property has no parameters. (If you don&#39;t specify null, you must
			// specify an array of Type objects. For a parameterless property,
			// use the built-in array with no elements: Type.EmptyTypes)
			var pbNumber = tb.DefineProperty(
				&quot;Number&quot;,
				PropertyAttributes.HasDefault,
				typeof(int),
				null);

			// The property &quot;set&quot; and property &quot;get&quot; methods require a special
			// set of attributes.
			var getSetAttr = MethodAttributes.Public |
							 MethodAttributes.SpecialName | MethodAttributes.HideBySig;

			// Define the &quot;get&quot; accessor method for Number. The method returns
			// an integer and has no arguments. (Note that null could be
			// used instead of Types.EmptyTypes)
			var mbNumberGetAccessor = tb.DefineMethod(
				&quot;get_Number&quot;,
				getSetAttr,
				typeof(int),
				Type.EmptyTypes);

			var numberGetIL = mbNumberGetAccessor.GetILGenerator();
			// For an instance property, argument zero is the instance. Load the
			// instance, then load the private field and return, leaving the
			// field value on the stack.
			numberGetIL.Emit(OpCodes.Ldarg_0);
			numberGetIL.Emit(OpCodes.Ldfld, fbNumber);
			numberGetIL.Emit(OpCodes.Ret);

			// Define the &quot;set&quot; accessor method for Number, which has no return
			// type and takes one argument of type int (Int32).
			var mbNumberSetAccessor = tb.DefineMethod(
				&quot;set_Number&quot;,
				getSetAttr,
				null,
				new Type[] { typeof(int) });

			var numberSetIL = mbNumberSetAccessor.GetILGenerator();
			// Load the instance and then the numeric argument, then store the
			// argument in the field.
			numberSetIL.Emit(OpCodes.Ldarg_0);
			numberSetIL.Emit(OpCodes.Ldarg_1);
			numberSetIL.Emit(OpCodes.Stfld, fbNumber);
			numberSetIL.Emit(OpCodes.Ret);

			// Last, map the &quot;get&quot; and &quot;set&quot; accessor methods to the
			// PropertyBuilder. The property is now complete.
			pbNumber.SetGetMethod(mbNumberGetAccessor);
			pbNumber.SetSetMethod(mbNumberSetAccessor);

			// Define a method that accepts an integer argument and returns
			// the product of that integer and the private field m_number. This
			// time, the array of parameter types is created on the fly.
			var meth = tb.DefineMethod(
				&quot;MyMethod&quot;,
				MethodAttributes.Public,
				typeof(int),
				new Type[] { typeof(int) });

			var methIL = meth.GetILGenerator();
			// To retrieve the private instance field, load the instance it
			// belongs to (argument zero). After loading the field, load the
			// argument one and then multiply. Return from the method with
			// the return value (the product of the two numbers) on the
			// execution stack.
			methIL.Emit(OpCodes.Ldarg_0);
			methIL.Emit(OpCodes.Ldfld, fbNumber);
			methIL.Emit(OpCodes.Ldarg_1);
			methIL.Emit(OpCodes.Mul);
			methIL.Emit(OpCodes.Ret);

			// Finish the type.
			var t = tb.CreateType();

			// The following line saves the single-module assembly. This
			// requires AssemblyBuilderAccess to include Save. You can now
			// type &quot;ildasm MyDynamicAsm.dll&quot; at the command prompt, and
			// examine the assembly. You can also write a program that has
			// a reference to the assembly, and use the MyDynamicType type.
			//
			var assembly = Assembly.GetAssembly(t);
			var generator = new Lokad.ILPack.AssemblyGenerator();
			generator.GenerateAssembly(assembly, aName.Name + &quot;_1.dll&quot;);

			GetCil(aName.Name + &quot;_1.dll&quot;);

			var mi = t.GetMethod(&quot;MyMethod&quot;);
			var pi = t.GetProperty(&quot;Number&quot;);

			// Create an instance of MyDynamicType using the default
			// constructor.
			var o1 = Activator.CreateInstance(t);

			// Display the value of the property, then change it to 127 and
			// display it again. Use null to indicate that the property
			// has no index.
			Console.WriteLine(&quot;o1.Number: {0}&quot;, pi.GetValue(o1, null));
			pi.SetValue(o1, 127, null);
			Console.WriteLine(&quot;o1.Number: {0}&quot;, pi.GetValue(o1, null));

			// Call MyMethod, passing 22, and display the return value, 22
			// times 127. Arguments must be passed as an array, even when
			// there is only one.
			object[] arguments = { 22 };
			Console.WriteLine(&quot;o1.MyMethod(22): {0}&quot;, mi.Invoke(o1, arguments));

			// Create an instance of MyDynamicType using the constructor
			// that specifies m_Number. The constructor is identified by
			// matching the types in the argument array. In this case,
			// the argument array is created on the fly. Display the
			// property value.
			var o2 = Activator.CreateInstance(t, new object[] { 5280 });
			Console.WriteLine(&quot;o2.Number: {0}&quot;, pi.GetValue(o2, null));
		}

		public static void GetCil(string path)
		{
			// Save the Assembly and generate the MSIL code with ILDASM.EXE
			using (var p = new Process())
			{
				p.StartInfo.FileName =
					@&quot;C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.8 Tools\ildasm.exe&quot;;
				p.StartInfo.Arguments = &quot;/text /nobar \&quot;&quot; + path;
				p.StartInfo.UseShellExecute = false;
				p.StartInfo.CreateNoWindow = true;
				p.StartInfo.RedirectStandardOutput = true;
				p.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
				p.Start();
				var s = p.StandardOutput.ReadToEnd();
				p.WaitForExit();
				p.Close();

				Console.WriteLine(s);
			}
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[15,3,15,4,0],[16,4,16,59,0],[17,4,20,43,0],[24,4,25,40,0],[27,4,29,28,0],[32,4,35,30,0],[39,4,39,44,0],[40,4,43,21,0],[45,4,45,41,0],[51,4,51,34,0],[52,4,52,79,0],[55,4,55,34,0],[56,4,56,34,0],[57,4,57,42,0],[58,4,58,30,0],[64,4,67,22,0],[69,4,69,41,0],[73,4,73,34,0],[74,4,74,39,0],[75,4,75,38,0],[76,4,76,30,0],[85,4,89,11,0],[93,4,94,67,0],[99,4,103,22,0],[105,4,105,59,0],[109,4,109,38,0],[110,4,110,46,0],[111,4,111,34,0],[115,4,119,33,0],[121,4,121,59,0],[124,4,124,38,0],[125,4,125,38,0],[126,4,126,46,0],[127,4,127,34,0],[131,4,131,47,0],[132,4,132,47,0],[137,4,141,33,0],[143,4,143,39,0],[149,4,149,33,0],[150,4,150,41,0],[151,4,151,33,0],[152,4,152,29,0],[153,4,153,29,0],[156,4,156,28,0],[164,4,164,43,0],[165,4,165,57,0],[166,4,166,64,0],[168,4,168,34,0],[170,4,170,37,0],[171,4,171,37,0],[175,4,175,41,0],[180,4,180,63,0],[181,4,181,31,0],[182,4,182,63,0],[187,4,187,32,0],[188,4,188,72,0],[195,4,195,64,0],[196,4,196,63,0],[197,3,197,4,0],[200,3,200,4,0],[202,11,202,32,0],[203,4,203,5,0],[204,5,205,93,0],[206,5,206,54,0],[207,5,207,41,0],[208,5,208,39,0],[209,5,209,47,0],[210,5,210,57,0],[211,5,211,15,0],[212,5,212,42,0],[213,5,213,21,0],[214,5,214,15,0],[216,5,216,26,0],[217,4,217,5,0],[218,3,218,4,0]]);
    </script>
  </body>
</html>